[{"title":"使用docker搭建LNMP","date":"2018-12-27T03:44:30.000Z","path":"cjq6eesar0023louthz3kt8s9.html","text":"docker是最近几年兴起的一套容器化环境，其隔离性比较好，趁着有空研究了一下PHP的docker化，虽然单机使用感觉和rpm包便利性差不多，但是在分布式系统上面结合k8s等还是有一定的优势。 先放一张整体结构图 为什么nginx没放docker正常情况下大型项目中容器化的都是应用程序，像mysql之类的也很少用docker包装，而nginx作为负载使用基本没有容器化的必要。只不过有需求的话看过本文过后也可自行将nginx容器化。 资料收集docker官网的帮助文档，dockerhub的说明书都是很好的资料来源，面对陌生的docker包通常阅读其说明书很有效！ docker安装docker安装在不通时代不同操作系统不一样，这里的操作系统为centos7，使用rpm包安装 从docker官网下载rpm安装包 在终端中执行yum install &lt;安装包名字&gt;，然后安装就结束了 如果要开机自动启动docker则需设置systemctl enable docker docker 网络创建现在的docker不建议使用–link来建立连接，而使用新的方式终端执行12## docker 创建私有网络docker network create my-net docker memcached可以打开 https://hub.docker.com/_/memcached 看说明书终端执行1234#拉取memcached镜像docker pull memcached#启动memcached，加入my-net网络，后台执行，映射11211端口，始终跟随docker启动的时候启动docker run --name memcached --network my-net -d -p 11211:11211 --restart=always memcached docker mysql可以打开 https://hub.docker.com/_/mysql 看说明书为了现阶段的兼容性使用mysql5.7版本，其他版本自行变更即可，终端执行1234#拉取mysql镜像docker pull mysql:5.7#启动mysql，加入my-net网络，后台执行，映射3306端口，始终跟随docker启动的时候启动，将root的password设置为123456；额外的，根据官网mysql说明书，文件储存于/var/lib/mysql，配置文件通常位于/etc/mysql/my.cnf，而docker中的root用户默认可以被外部网络访问docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 --network my-net -d -p3306:3306 --restart=always mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci docker PHPdocker化PHP是最麻烦的步骤，因为涉及到PHP的各种扩展库，甚至一些私有扩展库，这里我们在基于官方PHP包的情况下用dockerfile创建自己的私有包。首先新建一个文件夹，在里面创建dockerfile文件，其中相关参数可以根据自身情况自行调整，如果使用TP，laravel，yaf甚至之前文章提到的自研PHP框架都能使用下面的dockerfile，值得注意的是里面的tgz包都是从pecl下载到dockerfile同一级目录，如果版本号不同则要自行更改文件中的名字；当然，如果网络没问题可以直接使用类似“pecl install memcached-3.0.3 &amp;&amp; docker-php-ext-enable memcached”替代123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172FROM php:7.1-fpmLABEL Name=php-fpm Version=0.0.1RUN apt-get update &amp;&amp; apt-get install -y \\ libfreetype6-dev \\ libjpeg62-turbo-dev \\ libmcrypt-dev \\ libpng-dev \\ libmemcached-dev \\ zlib1g-dev \\ libpq-dev \\ --no-install-recommends \\ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \\ &amp;&amp; docker-php-ext-install -j$(nproc) gd mcrypt gettext mysqli pdo_mysql pgsql pdo_pgsql COPY ./yaf-3.0.7.tgz /tmp/yaf-3.0.7.tgzRUN cd /tmp \\ &amp;&amp; mkdir yaf \\ &amp;&amp; tar -zxvf yaf-3.0.7.tgz -C yaf --strip-components=1 \\# &amp;&amp; rm yaf-3.0.7.tgz \\ &amp;&amp; docker-php-ext-configure /tmp/yaf --enable-yaf \\ &amp;&amp; docker-php-ext-install /tmp/yaf COPY ./memcached-3.0.4.tgz /tmp/memcached-3.0.4.tgzRUN cd /tmp \\ &amp;&amp; mkdir memcached \\ &amp;&amp; tar -zxvf memcached-3.0.4.tgz -C memcached --strip-components=1 \\# &amp;&amp; rm memcached-3.0.4.tgz \\ &amp;&amp; docker-php-ext-configure /tmp/memcached --enable-memcached \\ &amp;&amp; docker-php-ext-install /tmp/memcached# COPY ./imagick-3.4.3.tgz /tmp/imagick-3.4.3.tgz# RUN cd /tmp \\# &amp;&amp; mkdir imagick \\# &amp;&amp; tar -zxvf imagick-3.4.3.tgz -C imagick --strip-components=1 \\# &amp;&amp; rm imagick-3.4.3.tgz \\# &amp;&amp; docker-php-ext-configure /tmp/imagick --enable-imagick \\# &amp;&amp; docker-php-ext-install /tmp/imagick COPY ./redis-4.2.0.tgz /tmp/redis-4.2.0.tgzRUN cd /tmp \\ &amp;&amp; mkdir redis \\ &amp;&amp; tar -zxvf redis-4.2.0.tgz -C redis --strip-components=1 \\# &amp;&amp; rm redis-4.2.0.tgz \\ &amp;&amp; docker-php-ext-configure /tmp/redis --enable-redis \\ &amp;&amp; docker-php-ext-install /tmp/redis COPY ./swoole-4.2.9.tgz /tmp/swoole-4.2.9.tgzRUN cd /tmp \\ &amp;&amp; mkdir swoole \\ &amp;&amp; tar -zxvf swoole-4.2.9.tgz -C swoole --strip-components=1 \\# &amp;&amp; rm swoole-4.2.9.tgz \\ &amp;&amp; docker-php-ext-configure /tmp/swoole --enable-swoole \\ &amp;&amp; docker-php-ext-install /tmp/swoole COPY ./hachi0.0.3.tgz /tmp/hachi0.0.3.tgzRUN cd /tmp \\ &amp;&amp; mkdir hachi \\ &amp;&amp; tar -zxvf hachi0.0.3.tgz -C hachi --strip-components=1 \\# &amp;&amp; rm hachi0.0.3.tgz \\ &amp;&amp; docker-php-ext-configure /tmp/hachi --enable-hachi \\ &amp;&amp; docker-php-ext-install /tmp/hachi# 如果没有自己的php.ini则下列两行应被RUN mv $PHP_INI_DIR/php.ini.production $PHP_INI_DIR/php.ini替换 COPY ./php.ini /tmp/php.iniRUN mv /tmp/php.ini $PHP_INI_DIR/php.iniRUN apt-get autoremove \\ &amp;&amp; apt-get clean \\ &amp;&amp; apt-get autoclean \\ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* 接下来在终端中执行123docker build -t php-fpm:v0.0.1 ./#如果构建自己的dockerhub私有包则是docker build -t &lt;自己名字&gt;/php-fpm:v0.0.1 ./ 然后启动docker PHP123#启动php-fpm，加入my-net网络，后台执行，映射9000端口，始终跟随docker启动；#重点注意：挂载/data/www/default到docker中的/data/www/defaultdocker run --name php-fpm --network my-net -d -p 9000:9000 --restart=always -v /data/www/default:/data/www/default php-fpm:v0.0.1 对应的nginx配置：1234567location ~ \\.php$ &#123; root /data/www/default; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /data/www/default/$fastcgi_script_name; include fastcgi_params; &#125; 最后再说明几点： 如果要使用docker内部的my-net网络则再host处填写docker的name即可，比如php连接数据库，那么数据库的host就是mysql，连接memcached那么host就是memcached（看docker run写的–name） 如果要以cgi方式运行php且兼容fpm则docker run应改为：123docker run --name php --network my-net -d -p 9000:9000 --restart=always -v /data/www/default:/data/www/default php-fpm:v0.0.1 /usr/local/bin/php &lt;你的php文件&gt;#或者精简的完全cgi模式docker run --name php --network my-net -d php-fpm:v0.0.1 /usr/local/bin/php &lt;你的php文件&gt; 测试文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php//phpinfo();$cc = doSql('root','select');var_dump($cc);function doSql($keyword, $method = 'count') &#123; if ($method == 'count') &#123; $sql = \"select count(0) from user where User LIKE ?\"; &#125; else &#123; $sql = \"select * from user where User LIKE ?\"; &#125; $pdo = new PDO(\"mysql:host=mysql;port=3306;dbname=mysql\", \"root\", \"123456\", array( PDO::ATTR_PERSISTENT =&gt; true )); $pdo-&gt;exec(\"set names utf8\"); $dopdo = $pdo-&gt;prepare($sql); $dopdo-&gt;execute(array( '%' . $keyword . '%' )); $res = $dopdo-&gt;fetch(); if ($method == 'count') &#123; return $res; &#125; else &#123; return $res; &#125; &#125;$m = new Memcached;$servers = array( array('memcached', 11211, 33), array('memcached', 11211, 67));$m-&gt;addServers($servers);var_dump($m);$m-&gt;set('a','b',1);var_dump($m-&gt;get('a'));sleep(1); var_dump($m-&gt;get('a'));","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"架构","slug":"架构","permalink":"http://limao777.github.io/blog/tags/架构/"},{"name":"PHP","slug":"PHP","permalink":"http://limao777.github.io/blog/tags/PHP/"},{"name":"容器化","slug":"容器化","permalink":"http://limao777.github.io/blog/tags/容器化/"}]},{"title":"基于swoole PHP实现EDP协议服务端","date":"2018-05-11T07:26:13.000Z","path":"cjq6eesdx002bloutdxy4owvr.html","text":"简介&emsp;&emsp;EDP（Enhanced Device Protocol）协议是一种极简的设备协议，主要用于物联网设备，并且比MQTT还要轻量，其协议文档可以在中移动OneNET官方网站下载。 https://open.iot.10086.cn &emsp;&emsp;现在主要来讲讲怎么用PHP长连接方式实现一个简易的EDP协议，也是大概两年多前闲着没事自娱自乐做的一个小东西，以期更快地了解、理解这个协议。因当时暂未把QOS纳入该协议且作为大平台成员已知设备间命令会存在安全问题故PHP版本不包含QOS以及设备间命令功能。 技术准备一个合适的常驻内存运行的PHP框架&emsp;&emsp;可以使用原生的PHP Socket，也可以用国外的walkman之类的框架。当然，本篇是用的国产的swoole框架，各有各的优点也各有各的缺点，适合的就是好用的。 两个重要PHP内置方法&emsp;&emsp;hex2bin()与bin2hex()，对这两个方法不很清楚的童鞋可以去php.net官网看看说明 一个进制转换方法&emsp;&emsp;由于世界上最好的语言的超级字符串特性，通常在数据处理的时候需要将16进制与待处理数据进行转换，方法如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php /** * * arr=1，正(小端)，arr=2，反(大端) * * @param * N byte array $num */ public static function c16to10($num, $arr = 2) &#123; $res = $num; if (is_array($num)) &#123; foreach ($num as $p =&gt; $v) &#123; switch (strtoupper($num[$p])) &#123; case 'A': $num[$p] = 10; break; case 'B': $num[$p] = 11; break; case 'C': $num[$p] = 12; break; case 'D': $num[$p] = 13; break; case 'E': $num[$p] = 14; break; case 'F': $num[$p] = 15; break; &#125; &#125; $res = 0; if ($arr == 1) &#123; for ($p = 0; $p &lt; count($num, COUNT_NORMAL); $p ++) &#123; $res = $res + $num[$p] * pow(16, $p); &#125; &#125; else &#123; for ($p = count($num, COUNT_NORMAL) - 1; $p &gt;= 0; $p --) &#123; $res = $res + $num[$p] * pow(16, count($num, COUNT_NORMAL) - 1 - $p); &#125; &#125; &#125; return $res; &#125; 看文档做解析怎样才能将设备上报的数据转换成方便操作的数据&emsp;&emsp;有了上面三项准备接下来可以真正开始做事情了，需要做的就是对照EDP文档进行一步一步地一个字节一个字节地解析：&emsp;&emsp;1.将接收到的数据使用bin2hex转换成字符串&emsp;&emsp;2.使用c16to10方法转换字符串得到相对更好处理的十进制字符串&emsp;&emsp;经过以上两步得到的就是数字型字符串了，PHP中当然不区分这些，直接当作数字拿来使用即可 处理消息类型（第一个字节）&emsp;&emsp;根据文档消息头第一个字节为消息类型，bit4为1表示连接请求，bit4与bit5为1表示透传数据，bit7为1表示储存数据，除了这三个位意外其他的都是填充0，那么我们可以根据转换过后的数字来进行判断，如连接请求类型为00010000，通过c16to10方法后就是数字16，同样地，透传则为00110000=48，储存则是10000000=128。再通过if或者switch等方法就可以进行后面的数据处理了。 连接鉴权的处理&emsp;&emsp;从第十一个字节开始，后续分别是两个字节的设备长度，设备长度字节的设备ID号，然后是两个字节的鉴权长度以及鉴权长度字节的鉴权信息，以获取设备id长度为例，代码如下：1234//$cmd代表收到的二进制数据，cursor代表要去获取数据的游标 //获取dev_id长度 $dev_length = Helper_Arr::c16to10([$cmd[$cursor], $cmd[$cursor+1], $cmd[$cursor+2], $cmd[$cursor+3]]); $cursor = $cursor + 4; &emsp;&emsp;最后为了方便处理心跳包，使用memcache设置一个用户识别hash：12345$cache = Cache_Memcached::getInstance(); $c_key = md5('edp_conn' . $fd); $cache-&gt;set($c_key, $auth_str, 300); $c_key = md5('edp_fd' . $fd); $cache-&gt;set($c_key, $dev_id, 300); 心跳包的处理&emsp;&emsp;同之前的鉴权处理，如果从缓存不能获取到了用户识别hash则认为已经断线了（socket超时设置需同缓存时间一致）123456789101112131415public static function dealPing($fd, $cmd)&#123; $cache = Cache_Memcached::getInstance(); $c_key = md5('edp_conn' . $fd); $res = $cache-&gt;get($c_key); if(!empty($res))&#123; $cache-&gt;set($c_key, $res, 300); $c_key = md5('edp_fd' . $fd); $res = $cache-&gt;get($c_key); $cache-&gt;set($c_key, $res, 300); return 'd000'; &#125;else&#123; return '20020002'; &#125; &#125; 完整示例： 接入机&emsp;&emsp;使用CGI的方式执行接入机文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?phpif (! empty($_SERVER['REQUEST_URI'])) &#123; exit();&#125;// set_time_limit(0);ini_set('memory_limit', '128M');date_default_timezone_set(\"Asia/Chongqing\");define(\"ROOT\", realpath(dirname(__FILE__)));// define(\"ROOT_APP\", realpath(ROOT . \"/../app\"));// 加载APPLIB基础bootstraprequire_once (ROOT . '/../libs/AppLib/bootstrap.php'); //该文件主要作用为自动加载相关的包、方法等，因附属框架太复杂此处不放出。如果后续有使用PSR0类型的自动加载方式，自行修改代码手动加载即可// 开始$request_server = new requestServer(29876); //29876为监听的端口class requestServer&#123; public $url_pre = \"\"; private $serv; public $log_file = '/tmp/EDP.log'; public function __construct($port) &#123; $dev_hostnames = array( 'test-VirtualBox', ); $test_hostnames = array( 'OneNetTest_node02' ); $current_host_name = php_uname('n'); if (in_array($current_host_name, $dev_hostnames)) &#123; $this-&gt;url_pre = '127.0.0.1'; $mem_connect_addr = '127.0.0.1'; &#125; elseif (in_array($current_host_name, $test_hostnames)) &#123; $this-&gt;url_pre = '127.0.0.1'; $mem_connect_addr = '127.0.0.1'; &#125; else &#123; $this-&gt;url_pre = '127.0.0.1'; $mem_connect_addr = '127.0.0.1'; &#125; //此处根据三种开发环境配置三种不同配置文件，如果只有一种则直接写死即可 $this-&gt;serv = new swoole_server(\"0.0.0.0\", $port); $this-&gt;serv-&gt;set(array( 'log_file' =&gt; $this-&gt;log_file, 'heartbeat_check_interval' =&gt; 280, 'heartbeat_idle_time' =&gt; 300, // 'user' =&gt; 'apache', //监听1024以下端口时以xxx用户的权限来运行 // 'group' =&gt; 'www-data', 'worker_num' =&gt; 8, 'daemonize' =&gt; true, 'max_request' =&gt; 10000, 'dispatch_mode' =&gt; 2 )); $this-&gt;serv-&gt;on('Connect', array( $this, 'onConnect' )); $this-&gt;serv-&gt;on('Receive', array( $this, 'onReceive' )); $this-&gt;serv-&gt;on('Close', array( $this, 'onClose' )); $this-&gt;serv-&gt;start(); &#125; public function onConnect(swoole_server $request_server, $fd) &#123; // echo \"server: handshake success with fd&#123;$fd&#125;\\n\"; &#125; public function onReceive(swoole_server $request_server, $fd, $from_id, $data) &#123; if(empty($cache))&#123; $cache = Cache_Memcached::getInstance(); &#125; $cache-&gt;set(\"edp_ip\" . $fd,$request_server-&gt;connection_info($fd)['remote_ip'], 300); $ret_msg = $this-&gt;__dealCmd($fd, $data); if (! empty($ret_msg)) &#123; $request_server-&gt;send($fd, hex2bin($ret_msg)); &#125; $deal_code = Service_Edp_Dealcode::dealCode($ret_msg); if ($deal_code !== 1) &#123; if (! empty($deal_code)) &#123; $request_server-&gt;send($fd, hex2bin($deal_code)); &#125; $request_server-&gt;close($fd); &#125; &#125; public function onClose($ser, $fd) &#123; // echo \"client &#123;$fd&#125; closed\\n\"; &#125; private function __dealCmd($fd, $cmd) &#123; $cmd = bin2hex($cmd); $command = Helper_Arr::c16to10([ $cmd[0], $cmd[1] ]); switch ($command) &#123; case 16: return Service_Edp_Connect::dealConnect($fd, $cmd); break; case 128: return Service_Edp_Datas::save($fd, $cmd); break; case 192: return Service_Edp_Connect::dealPing($fd, $cmd); break; default: break; &#125; return '400104'; &#125; protected function _log($msg) &#123; // echo 'log: ' . $msg . \"\\n\"; file_put_contents($this-&gt;log_file, date('Y-m-d H:i:s') . ' - ' . $msg . \"\\n\", FILE_APPEND); return; &#125;&#125; 处理鉴权和心跳 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Service_Edp_Connect extends Service_Base&#123; public function __construct() &#123; &#125; public static function dealConnect($fd, $cmd)&#123; $cursor = 22; //获取dev_id长度 $dev_length = Helper_Arr::c16to10([$cmd[$cursor], $cmd[$cursor+1], $cmd[$cursor+2], $cmd[$cursor+3]]); $cursor = $cursor + 4; //取dev_id $temp = \"\"; for ($i =0; $i&lt;$dev_length*2;$i++)&#123; $temp .= $cmd[$cursor+$i] . \"\"; &#125; $dev_id = hex2bin($temp); $cursor = $cursor + $dev_length*2; //鉴权信息长度 $auth_length = Helper_Arr::c16to10([$cmd[$cursor], $cmd[$cursor+1], $cmd[$cursor+2], $cmd[$cursor+3]]); $cursor = $cursor + 4; //鉴权信息(api-key) $temp = \"\"; for ($i =0; $i&lt;$auth_length*2;$i++)&#123; $temp .= $cmd[$cursor+$i] . \"\"; &#125; $auth_str = hex2bin($temp); $cursor = $cursor + $auth_length*2; //开始鉴权 $auth = [ 'dev_id' =&gt; $dev_id, 'api-key' =&gt; $auth_str ]; if(Service_Device::checkAuth($auth))&#123; $cache = Cache_Memcached::getInstance(); $c_key = md5('edp_conn' . $fd); $cache-&gt;set($c_key, $auth_str, 300); $c_key = md5('edp_fd' . $fd); $cache-&gt;set($c_key, $dev_id, 300); return '20020000'; &#125;else&#123; return '20020002'; &#125; &#125; public static function dealPing($fd, $cmd)&#123; $cache = Cache_Memcached::getInstance(); $c_key = md5('edp_conn' . $fd); $res = $cache-&gt;get($c_key); if(!empty($res))&#123; $cache-&gt;set($c_key, $res, 300); $c_key = md5('edp_fd' . $fd); $res = $cache-&gt;get($c_key); $cache-&gt;set($c_key, $res, 300); return 'd000'; &#125;else&#123; return '20020002'; &#125; &#125; &#125; 保存上传数据到kafka 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222class Service_Edp_Datas extends Service_Base&#123; public static function save($fd, $cmd) &#123; $cursor = 2; $cache = Cache_Memcached::getInstance(); // 先分离消息体长度 for ($i = 0; $i &lt; 4; $i ++) &#123; $body_length_fenli = Helper_Arr::c16to10([ $cmd[$cursor], $cmd[$cursor + 1] ]) &amp; 0x80; $cursor = $cursor + 2; if (empty($body_length_fenli)) &#123; break; &#125; &#125; // 过滤固定选项：标识 $fix_note = Helper_Arr::c16to10([ $cmd[$cursor], $cmd[$cursor + 1] ]); $cursor = $cursor + 2; $note_no = ''; // 如果有目标或源地址，开始 if ($fix_note == 128 || $fix_note == 192) &#123; // 目的或源地址 - 长度 $addr_length = Helper_Arr::c16to10([ $cmd[$cursor], $cmd[$cursor + 1], $cmd[$cursor + 2], $cmd[$cursor + 3] ]); $cursor = $cursor + 4; // 目的或源地址 - 具体内容 $temp = \"\"; for ($i = 0; $i &lt; $addr_length * 2; $i ++) &#123; $temp .= $cmd[$cursor + $i] . \"\"; &#125; $addr = hex2bin($temp); $cursor = $cursor + $addr_length * 2; if ($fix_note == 192) &#123; $note_no = $cmd[$cursor] . $cmd[$cursor + 1] . $cmd[$cursor + 2] . $cmd[$cursor + 3]; $cursor = $cursor + 4; &#125; &#125; // 如果有目标或源地址，结束 elseif ($fix_note == 0) &#123; $c_key = md5('edp_fd' . $fd); $addr = $cache-&gt;get($c_key); if (empty($addr)) &#123; $addr = 0; &#125; &#125; elseif ($fix_note == 64) &#123; $note_no = $cmd[$cursor] . $cmd[$cursor + 1] . $cmd[$cursor + 2] . $cmd[$cursor + 3]; $cursor = $cursor + 4; &#125; else &#123; return '20020002'; &#125; // 如果没有目标或源地址，结束 // //消息编号（似乎没有） // $msg_id = Helper_Arr::c16to10([$cmd[$cursor], $cmd[$cursor+1], $cmd[$cursor+2], $cmd[$cursor+3]]); // $cursor = $cursor + 4; // 数据消息类型 $data_type = Helper_Arr::c16to10([ $cmd[$cursor], $cmd[$cursor + 1] ]); $cursor = $cursor + 2; // 数据消息 - 长度 $data_length = Helper_Arr::c16to10([ $cmd[$cursor], $cmd[$cursor + 1], $cmd[$cursor + 2], $cmd[$cursor + 3] ]); $cursor = $cursor + 4; // 数据消息 - 具体内容 $temp = \"\"; for ($i = 0; $i &lt; $data_length * 2; $i ++) &#123; $temp .= $cmd[$cursor + $i] . \"\"; &#125; $data_body = hex2bin($temp); $cursor = $cursor + $data_length * 2; // 是二进制数据，特殊处理 if ($data_type == 2) &#123; $data_bin_length = Helper_Arr::c16to10([ $cmd[$cursor], $cmd[$cursor + 1], $cmd[$cursor + 2], $cmd[$cursor + 3], $cmd[$cursor + 4], $cmd[$cursor + 5], $cmd[$cursor + 6], $cmd[$cursor + 7] ]); $cursor = $cursor + 8; $temp = \"\"; for ($i = 0; $i &lt; $data_bin_length * 2; $i ++) &#123; $temp .= $cmd[$cursor + $i] . \"\"; &#125; $data_bin_body = hex2bin($temp); $cursor = $cursor + $data_bin_length * 2; &#125; // --------------EDP包解析结束--------------// // 数据鉴权 $c_key = md5('edp_conn' . $fd); $auth_str = $cache-&gt;get($c_key); if (! empty($auth_str)) &#123; $kafka_array = []; $kafka_array['datastreams'] = []; switch ($data_type) &#123; case 1: $kafka_array = json_decode($data_body, TRUE); break; case 2: // 二进制数据 $input_data = json_decode($data_body, TRUE); if (empty($input_data) || ! is_array($input_data)) &#123; return '20020001'; &#125; if (is_array($input_data)) &#123; $kafka_array['datastreams'][0]['id'] = $input_data['ds_id']; $kafka_array['datastreams'][0]['datapoints'][0]['at'] = empty($input_data['at']) ? date('Y-m-d\\TH:i:s') : $input_data['at']; $kafka_array['datastreams'][0]['datapoints'][0]['value'] = $data_bin_body; $kafka_array['datastreams'][0]['datapoints'][0]['desc'] = $input_data['desc']; &#125; break; case 3: $input_data = json_decode($data_body, TRUE); if (empty($input_data) || ! is_array($input_data)) &#123; return '20020001'; &#125; if (is_array($input_data)) &#123; $count = 0; foreach ($input_data as $p =&gt; $v) &#123; $kafka_array['datastreams'][$count]['id'] = $p; $kafka_array['datastreams'][$count]['datapoints'][0]['at'] = date('Y-m-d\\TH:i:s'); $kafka_array['datastreams'][$count]['datapoints'][0]['value'] = $v; $count ++; &#125; &#125; break; case 4: $input_data = json_decode($data_body, TRUE); if (empty($input_data) || ! is_array($input_data)) &#123; return '20020001'; &#125; if (is_array($input_data)) &#123; $count = 0; foreach ($input_data as $p =&gt; $v) &#123; $kafka_array['datastreams'][$count]['id'] = $p; if (is_array($input_data[$p])) &#123; foreach ($input_data[$p] as $p2 =&gt; $v2) &#123; $kafka_array['datastreams'][$count]['datapoints'][0]['at'] = $p2; $kafka_array['datastreams'][$count]['datapoints'][0]['value'] = $v2; &#125; &#125; else &#123; return '20020001'; &#125; $count ++; &#125; // foreach inputdata &#125; break; case 5: $split1 = mb_substr($data_body, 0, 1); $split2 = mb_substr($data_body, 1, 1); $real_str = mb_substr($data_body, 2, strlen($data_body) - 2); $ds_array = explode($split2, $real_str); if (is_array($ds_array)) &#123; foreach ($ds_array as $p =&gt; $v) &#123; $dp_array = explode($split1, $v); if (count($dp_array, COUNT_NORMAL) == 2) &#123; $kafka_array['datastreams'][$p]['id'] = $dp_array[0]; $kafka_array['datastreams'][$p]['datapoints'][0]['at'] = date('Y-m-d\\TH:i:s'); $kafka_array['datastreams'][$p]['datapoints'][0]['value'] = $dp_array[1]; &#125; elseif (count($dp_array, COUNT_NORMAL) == 1) &#123; $kafka_array['datastreams'][$p]['id'] = $p; $kafka_array['datastreams'][$p]['datapoints'][0]['at'] = date('Y-m-d\\TH:i:s'); $kafka_array['datastreams'][$p]['datapoints'][0]['value'] = $dp_array[0]; &#125; else &#123; $kafka_array['datastreams'][$p]['id'] = $dp_array[0]; $kafka_array['datastreams'][$p]['datapoints'][0]['at'] = $dp_array[1]; $kafka_array['datastreams'][$p]['datapoints'][0]['value'] = $dp_array[2]; &#125; &#125; &#125; // if ds is array break; &#125; // switch $auth = [ 'dev_id' =&gt; $addr, 'api-key' =&gt; $auth_str ]; $ip = $cache-&gt;get(\"edp_ip\" . $fd); if (! Helper_Kafka::sendToDp($auth, $kafka_array, TRUE, $ip)) &#123; return '20020001'; &#125; else &#123; if(empty($note_no))&#123; return '900440' . $note_no . '00'; &#125;else&#123; return ''; &#125; &#125; &#125; else &#123; return '20020002'; &#125; &#125;&#125; 相关的其他支持类 123456789101112131415161718192021class Service_Edp_Dealcode extends Service_Base&#123; public static function dealCode($code) &#123; $code = strtolower($code); if (strlen($code) &gt; 10) &#123; return 1; &#125; elseif ($code == 'd000') &#123; return 1; &#125; elseif ($code == '20020000') &#123; return 1; &#125; elseif ($code == '') &#123; return 1; &#125; elseif ($code == '20020002') &#123; return '400120'; &#125; else &#123; return '400101'; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221class Cache_Memcached&#123; protected static $_objList; private $_memcache; private $_config_name; private function __construct($config_name) &#123; $this-&gt;_config_name = $config_name; &#125; private function init() &#123; $memcacheHosts = Config::get($this-&gt;_config_name); $memcacheHosts = explode(',', $memcacheHosts); if (empty($memcacheHosts)) &#123; return FALSE; &#125; else &#123; $this-&gt;_memcache = new Memcache; foreach ($memcacheHosts as $m) &#123; list($host, $port) = explode(':', $m); $this-&gt;_memcache-&gt;addServer($host, $port); &#125; &#125; &#125; /** * 获取一个Cache_Memcache实例 * * @param integer $clusterId cluster id * @return object */ public static function getInstance($config_name = 'DefaultMemcacheServers') &#123; if (empty(self::$_objList[$config_name])) &#123; $obj = new self($config_name); $obj-&gt;init(); self::$_objList[$config_name] = &amp;$obj; &#125; return self::$_objList[$config_name]; &#125; /** * 获取缓存的静态方法 * * @param string|array $key * @param integer $clusterId cluster id * @return mixed */ public static function sGet($key) &#123; $instance = self::getInstance(); return $instance-&gt;get($key); &#125; /** * 设置缓存的静态方法 * * @param string $key * @param mixed $val * @param integer $expires 过期时间（秒），0为永不过期 * @param integer $clusterId cluster id * @return boolean */ public static function sSet($key, $val, $compress = MEMCACHE_COMPRESSED, $expires = 0) &#123; $instance = self::getInstance(); return $instance-&gt;set($key, $val, $compress, $expires); &#125; /** * 删除缓存数据的静态方法 * * @param string $key * @param integer $clusterId * @return boolean */ public static function sDelete($key) &#123; $instance = self::getInstance(); return $instance-&gt;delete($key); &#125; /** * 增加缓存的静态方法 * * @param string $key * @param mixed $val * @param integer $expires * @param integer $clusterId * @return boolean */ public static function sAdd($key, $val, $compress = MEMCACHE_COMPRESSED, $expires = 0) &#123; $instance = self::getInstance(); return $instance-&gt;add($key, $val, $compress, $expires); &#125; /** * 获取缓存数据 * * @param string $key * @return mixed */ public function get($key) &#123; if (empty($this-&gt;_memcache)) &#123; if ( ! $this-&gt;init()) &#123; return FALSE; &#125; &#125; $res = $this-&gt;_memcache-&gt;get($key); return $res; &#125; /** * 写入缓存 * * @param string $key 数据对应的键名 * @param mixed $val 数据 * @param integer $expires 缓存的时间（秒），设置为0表示永不过期 * @return boolean */ public function set($key, $val, $expires = 0) &#123; if (empty($this-&gt;_memcache)) &#123; if ( ! $this-&gt;init()) &#123; return FALSE; &#125; &#125; if (is_numeric($val)) &#123; $val = (string) $val; &#125; $ret = $this-&gt;_memcache-&gt;set($key, $val, 0, $expires); //兼容以前程序，直接写0 return $ret; &#125; /** * 删除缓存 * * @param string $key 数据的键名 * @return boolean */ public function delete($key) &#123; if (empty($this-&gt;_memcache)) &#123; if ( ! $this-&gt;init()) &#123; return FALSE; &#125; &#125; $ret = $this-&gt;_memcache-&gt;delete($key, 0); return $ret; &#125; /** * 增加item的值 * * @param string $key * @param integer $val * @return boolean */ public function increment($key, $val = 1) &#123; if (empty($this-&gt;_memcache)) &#123; if ( ! $this-&gt;init()) &#123; return FALSE; &#125; &#125; $ret = $this-&gt;_memcache-&gt;increment($key, $val); return $ret; &#125; /** * 写入缓存当且仅当$key对应缓存不存在的时候 * * @param string $key * @param mixed $val * @param integer $expires * @return boolean */ public function add($key, $val, $compress = MEMCACHE_COMPRESSED, $expires = 0) &#123; if (empty($this-&gt;_memcache)) &#123; if ( ! $this-&gt;init()) &#123; return FALSE; &#125; &#125; $ret = $this-&gt;_memcache-&gt;add($key, $val, $compress, $expires); return $ret; &#125; /** * 刷新 * * @return boolean */ public function flush() &#123; if (empty($this-&gt;_memcache)) &#123; if ( ! $this-&gt;init()) &#123; return FALSE; &#125; &#125; $ret = $this-&gt;_memcache-&gt;flush(); return $ret; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Helper_Kafka&#123; private static $__kafka_addr = '127.0.0.1:9092'; public static $error = ''; public static function sendToDp($auth, $input_data, $check_data = TRUE, $ip = NULL, $topic = 'dp_test') &#123; if(!is_array($auth))&#123; self::$error = 'auth mot match'; return FALSE; &#125; $check_auth = Service_Device::checkAuth($auth); if(!$check_auth)&#123; self::$error = 'auth failed'; return FALSE; &#125; $check_dp = Service_Datapoints::checkPostDp($input_data); $input_kafka_array = []; if(empty($ip))&#123; $input_kafka_array['ip'] = Service_Http::getClientIP(); &#125;else&#123; $input_kafka_array['ip'] = $ip; &#125; $input_kafka_array['auth'] = $auth; $input_kafka_array['data'] = $input_data; $input_kafka = json_encode($input_kafka_array, JSON_UNESCAPED_UNICODE); if($check_dp)&#123; self::storeToLocal($auth['dev_id'], $input_data); $kafka = new Kafka(self::$__kafka_addr); $res = $kafka-&gt;produce($topic, $input_kafka); $kafka = NULL; return TRUE; &#125;else&#123; self::$error = Service_Datapoints::$error; return FALSE; &#125; &#125; public static function storeToLocal($dev_id, $input_data)&#123; $cache = Cache_Memcached::getInstance(); $cache-&gt;set($dev_id,$input_data, 80000*30); &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://limao777.github.io/blog/tags/PHP/"},{"name":"EDP","slug":"EDP","permalink":"http://limao777.github.io/blog/tags/EDP/"},{"name":"协议","slug":"协议","permalink":"http://limao777.github.io/blog/tags/协议/"}]},{"title":"开发一个新框架-Hachi","date":"2018-04-12T02:17:11.000Z","path":"cjq6eert3000ilout9zxbfony.html","text":"&emsp;&emsp;近几年陆续开发了一些Web应用和其他应用，需求或简单或复杂，实现或优雅或丑陋。一个基本的事实是：只是积累了一些经验或提高了对编程语言以及涉及到的开发业务的熟悉程度。&emsp;&emsp;随着软件开发经验的不断增加，其实很多工作都是重复机械的,框架是实现了某应用领域通用功能的底层服务。使用这种框架的编程人员可以在一个通用功能已经实现的基础上开始具体的系统开发。框架提供了所有应用期望的默认行为的类集合。具体的应用通过重写子类或组装对象来支持应用专用的行为。通俗的说，框架是完成是某种应用的半成品，提供了一些常用的工具类和一些基础通用化的组件，可以供开发人员在此基础上，更便捷的完成各自特有的系统。&emsp;&emsp;开发一个系统时，我们不可避免的会使用各种框架：数据层、路由曾、日志、长连接、自动映射等。一个高质量的软件系统往往还有全局容错，消息队列等组件。把上述这些组件组合到一起的时候，其复杂度会急剧上升。&emsp;&emsp;其实，我们无非是希望在编程的时候，把大部分的注意力全部集中到业务实现上。不要过多的考虑基础的软件结构上的种种问题，应该有一个框框或者一种范式来提供基本的服务。&emsp;&emsp;现有的PHP框架较为流行的如TP、YII、CI、yaf等，但均适用于网页型的开发，但是大规模开发中通常后端开发有很多场景：&emsp;&emsp;以CMCC IOTEAM团队的后端开发为例，大体如下： 网页/后台管理开发（php-yaf） 短连接API开发（php-yaf） TCP/UDP服务（php-swoole） 异步队列/api（php-swoole） 多线程/进程并发（php-pcntl） 定时任务（crontab）&emsp;&emsp;一个很明确的事情就是在这样的团队中一个后端开发就需招聘擅长不同框架语言的程序员来开发，维护性大打折扣！&emsp;&emsp;稍微正规一点的公司经过多年沉淀都形成了自己的内部软件框架，他们在开发软件的时候并不是从一片空白开始的。而是从一个非常牢固的基础平台上开始构建的。这样大大提高了开发速度。基于此，距今大约一年的样子，在2017年4月份开发出了PHP-HACHI框架，只需要一个框架就可完成上述所有开发。&emsp;&emsp;它并没有使用任何新的技术，只是将一些东西整合到了一起，并提供了一个不复杂也不轻量的路由、一个统一的上下文结构以支持不变更代码即可通用cgi部署和传统的FPM部署、自动加载器、cgi部署管理器以及一个简单的不能再简单的日志类。&emsp;&emsp;框架发布已经一年，团队内部也使用它做了好几个项目了，从一开始的OneNET触屏版项目强制使用cgi部署导致了原有熟悉fpm开发模式的PHPer各种不适应到后面系统监控报警系统大大地感受到了cgi部署带来的诸如TCP监听、定时任务的带来的极大开发方便，再到最后面几个经典的网站应用项目也从yaf变更到了hachi，最重要的两个指标的安全性、稳定性算是基本通过了考验。&emsp;&emsp;后续还会对框架进行大规模更新甚至重构，最后希望达到的效果就是如果是基于PHP开发，只用一个框架就解决问题。https://github.com/limao777/Hachi-PHP-Framework","tags":[{"name":"web","slug":"web","permalink":"http://limao777.github.io/blog/tags/web/"},{"name":"架构","slug":"架构","permalink":"http://limao777.github.io/blog/tags/架构/"}]},{"title":"线程相关概念以及pthread","date":"2017-11-16T06:02:07.000Z","path":"cjq6eert6000qlout9l3oyrdm.html","text":"几个知识点创建线程之后，地址空间没有变化进程退出成了线程-主线程主线程和子线程有各自独立的pcb（子线程的pcb是从主线程拷贝来的）在linux下，线程就是轻量级进程（内核看pcb） 主线程和子线程共享的数据.text(代码段).bss（未初始化的变量）.data（已初始化的变量）堆动态库家再去环境变量命令行参数– 线程间通信可以依靠全局变量、堆 主线程和子线程不共享的数据栈(栈区被线程平均分配) （补充）进程间共享的资源代码文件描述符内存映射区 – mmap 查看指定线程的LWP号ps -Lf {pid}注意线程号和进程ID是有区别的，线程号给内核看 线程相关函数创建线程函数原型12345678//如果成功返回0，失败返回错误号//perror()不能使用该函数打印错误信息，它只是个数字itn pthread_create(pthread_t *thread, //线程ID=无符号长整型const pthread_attr_t *attr, //线程属性，通常为NULLvoid *(*start_routine) (void *), //线程处理函数void *arg //线程处理函数参数); 参数 thread：创出参数，线程创建成功以后，会被设置一个合适的值 attr：默认传NULL start_routine：子线程的处理函数 arg：回调函数的参数主线程先退出，子线程会被强制结束 单个线程退出函数原型1void pthread_exit(void *retval); 阻塞等待线程退出，获取线程退出状态函数原型1int pthread_join(pthread_t thread, void **retval); 线程分离函数原型1int pthread_detach(pthread_t thread); 调用该函数后不需要pthread_join()，子线程会自动回收自己的PCB 杀死（取消）线程函数原型1int pthread_cancel(pthread_t thread); 在要杀死的子线程对应的处理函数的内部必须做过一次系统调用 简单的e.g.123456789101112131415161718192021222324252627282930//gcc编译时参数加上 -lpthrad#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;void* myfunc(void* arg)&#123; int num = *(int*)arg; printf(\"%dth child thread id:%ld\\n\", num, pthread_self()); return NULL;&#125;int main(int argc, const char* argv[])&#123; //创建一个子线程 int i = 0; pthread_t pthid[5]; for(i=0;i&lt;5;++i)&#123; pthread_create(&amp;pthid[i], NULL, myfunc, (void*)&amp;i); //此处用的引用传递，会导致多线程的i有可能取到同一个 &#125; printf(\"parent thread id:%ld\\n\", pthread_self()); for(i=0;i&lt;5;i++)&#123; printf(\"i=%d\\n\",i); &#125; sleep(2); return 0;&#125;","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"C语言","slug":"C语言","permalink":"http://limao777.github.io/blog/tags/C语言/"}]},{"title":"用C语言创建一个守护进程并使用定时器","date":"2017-11-14T07:10:58.000Z","path":"cjq6eert5000nloutfsr9xust.html","text":"守护进程的特点 后台服务进程 独立于控制终端 周期性执行某任务 不受用户登陆注销影响 一般采用以d结尾的名字（服务） 进程组进程组组长一般是组里面第一个进程进程组的ID==进程组组长的ID 会话 - 多个进程组创建一个会话注意事项不能是进程组长创建会话的进程成为新进程组的组长有些linux版本需要root权限执行次操作（ubuntu不需要）创建出的新会话会丢弃原有的控制终端一般步骤：先fork，父进程死，子进程执行创建会话操作 获取进程所属的会话IDpid_t getsid(pid_t pid); 创建一个会话pid_t setsid(void); ##创建守护进程模型fork子进程，父进程退出子进程创建新会话改变当前工作目录chdir重设文件掩码关闭文件描述符执行核心工作 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;void dowork(int no)&#123; time_t curtime; //get current sys time and write it to file time(&amp;curtime); //format time char *pt = ctime(&amp;curtime); int fd = open(\"/tmp/aaaaattt.txt\", O_CREAT | O_WRONLY | O_APPEND, 0644); write(fd, pt, strlen(pt)+1); close(fd);&#125;int main(int argc, const char* argv[])&#123; pid_t pid = fork(); if(pid&gt;0)&#123; exit(1); &#125; else if(pid==0)&#123; setsid(); //改变进程工作目录 chdir(\"/tmp\"); //配置文件掩码 umask(0); //关闭文件描述符 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); //执行核心操作，注册信号捕捉 struct sigaction act; act.sa_handler = 0; act.sa_handler = dowork; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); //创建定时器 struct itimerval val; //首次触发时间 val.it_value.tv_usec = 0; val.it_value.tv_sec = 2; //循环周期 val.it_interval.tv_usec = 0; val.it_interval.tv_sec = 1; setitimer(ITIMER_REAL, &amp;val, NULL); while(1); &#125; return 0;&#125;","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"C语言","slug":"C语言","permalink":"http://limao777.github.io/blog/tags/C语言/"}]},{"title":"makefile相关概念","date":"2017-10-30T07:37:46.000Z","path":"cjq6eersy000bloutmgjwrxel.html","text":"make一个概念：gcc -&gt; 编译器make -&gt; linux自带的构建器，构建的规则在makefile中 makefile文件的命名 makefile、Makefile两者均可 makefile中的规则如：gcc a.c b.c c.c -o app分为三个部分：目标、依赖、命令（makefile文件中）使用目标：依赖（换行）（tab缩进）命令： 第一个版本的编写12app:a.c b.c c.c&#123;TAB&#125;gcc a.c b.c c.c -o app 然后执行make命令即可 第二个版本的编写，优化编译原理： 检测依赖是否存在：向下搜索下边的规则，如果有规则是用来生成查找依赖的，执行规则中的命令 依赖存在：判断是否需要更新，原则：目标时间&gt;依赖时间，反之，则更新1234567891011app:a.o b.o c.o&#123;TAB&#125;gcc a.o b.o c.o -o appa.o:a.c&#123;TAB&#125;gcc a.c -cb.o:b.c&#123;TAB&#125;gcc b.c -cc.o:c.c&#123;TAB&#125;gcc c.c -c 第三个版本自定义变量(通常用小写):obj=a.o b.o c.oobj=10变量的取值：aa=$(obj)makefile自带的变量：大写 CPPFLAGS CC自动变量： $@：规则中的目标 $&lt;：规则中的第一个依赖 $^：规则中所有的依赖自动变量只能在规则中的命令中使用1234567obj = a.o b.o c.otarget = app$(target):$(obj)&#123;TAB&#125;gcc $(obj) -o $(target)%.o:%.c&#123;TAB&#125;gcc -c $&lt; -o $@ 模式匹配：%.o:%.c第一次：a.o没有%就匹配了a，变成了gcc -c a.c -o a.o第二次和第三次类似 第四个版本，解决可移植性比较差的问题先介绍几个函数： 查找指定目录下指定类型的文件：wildcard #e.g. src = $(wildcard ./*.c) //空格后面加上参数 匹配替换：patsubst #e.g. obj = $(patsubst %.c,%.o,$(src)) //匹配用百分号，将src中的.c替换为.o12345678src = $(wildcard ./*.c)obj = $(patsubst %.c,%.o,$(src))target = app$(target):$(obj)&#123;TAB&#125;gcc $(obj) -o $(target) #或gcc $^ -o $@%.o:%.c&#123;TAB&#125;gcc -c $&lt; -o $@ 第五个版本，带自动清理项目即让make生成不是终极目标的目标123456789101112src = $(wildcard ./*.c)obj = $(patsubst %.c,%.o,$(src))target = app$(target):$(obj)&#123;TAB&#125;gcc $(obj) -o $(target) #或gcc $^ -o $@%.o:%.c&#123;TAB&#125;gcc -c $&lt; -o $@.PHONY:CLEAN #声明clean为为目标，使clean不受文件爱你更新检查的干扰clean:&#123;TAB&#125;-rm $(obj) $(target) -f #&quot;-&quot;表示如果执行失败继续执行后面的，-f是rm的参数，强制执行不报错 执行make clean即可","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"编译技术","slug":"编译技术","permalink":"http://limao777.github.io/blog/tags/编译技术/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"}]},{"title":"hibernate介绍与快速入门","date":"2017-10-30T02:11:35.000Z","path":"cjq6eerst0005loutqpilzyaj.html","text":"应用场景一个数据库框架，使用hibernate后可以使用hql语句操作数据库，如果涉及到数据库迁移等则无需改代码，使开发人员更关注业务本身 快速入门hibernate和structs说明hibernate可以用在j2se和j2ee中，而struts是web框架，一般用于j2ee项目 开发流程创建一个项目引入hibernate开发包从网上下载 开发的三种方式 由Domain object -&gt; mapping -&gt; db（官方推荐） 由DB开始，用工具生成mapping和Domain object（使用较多） 由映射文件开始 使用第二种方式开发项目 创建表和序列(使用oracle) 1234567891011121314create table employee(id number primary key,name varchar2(64) not null,email varchar(64) not null,hiredate date not null);create sequence emp_seq(start with 1,increment by 1,min value 1,nomaxvalue,nocycle,nocache,); 开发domain对象和对象映射文件，用于指定domain对象和表的映射关系，该文件取名有规范：domain对象.hbm.xml，一般放在和domain对象同一个文件夹下 12345678910111213141516171819202122232425262728293031323334353637383940//package com.lm.domainimport java.io.Serializable;//domain对象那个名称就是对应首字母的大写//domain对象，也叫javabean或pojo(plain ordinary java objects)public class Employee implements Serializable&#123; /** * */ private static final long serialVersionUID = 1L; private Integer id; private String name; private String email; private java.util.Date hiredate; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public java.util.Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(java.util.Date hiredate) &#123; this.hiredate = hiredate; &#125;&#125; 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- package : 表示该类在哪个包下 --&gt;&lt;hibernate-mapping package=\"com.lm.domain\"&gt;&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt; &lt;class name=\"Employee\" table=\"employee\"&gt; &lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt; &lt;!-- name:表示类的哪个属性是主键 --&gt; &lt;id name=\"id\" type=\"java.lang.Integer\"&gt; &lt;!-- 指定主键生成策略 --&gt; &lt;generator class=\"sequence\"&gt; &lt;param name=\"sequence\"&gt;emp_seq&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\" type=\"java.lang.String\"&gt; &lt;column name=\"name\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;property name=\"email\" type=\"java.lang.String\"&gt; &lt;column name=\"email\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;property name=\"hiredate\" type=\"java.util.Date\"&gt; &lt;column name=\"hiredate\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 手动配置hibernate.cfg.xml文件（文件名一般不用改，但是也可以改成其他名字），该文件用于配置连接数据库的类型,driver、用户名、密码等，位于src根目录 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;&lt;!-- 该文件用于配置连接数据的种类,用户名，密码,ul ,驱动.. 连接池,二级缓存.. 有点类似strus struts-config.xml --&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"connection.driver_class\"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:oracle:thin:@127.0.0.1:1521:orclhsp&lt;/property&gt; &lt;property name=\"connection.username\"&gt;scott&lt;/property&gt; &lt;property name=\"connection.password\"&gt;tiger&lt;/property&gt; &lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!-- 配置数据库的方言/ --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt; &lt;!-- 配置管理的对象映射文件 --&gt; &lt;mapping resource=\"com/hsp/domain/Employee.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.lm.view;import java.sql.Date;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.lm.domain.Employee;import com.lm.utils.MySessionFactory;public class TestMain &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub SessionFactory sessionFactory= MySessionFactory.getSessionFactory(); Session session=sessionFactory.openSession(); //查询可以不使用事务 Employee emp=(Employee) session.load(Employee.class, 3); System.out.println(emp.getName()+\" \"+emp.getEmail()); session.close(); &#125; public static void delEmp() &#123; // TODO Auto-generated method stub SessionFactory sessionFactory= MySessionFactory.getSessionFactory(); Session session=sessionFactory.openSession(); //删除一个雇员,先得到，再修改 Transaction ts=session.beginTransaction(); Employee emp=(Employee) session.load(Employee.class, 2); session.delete(emp); ts.commit(); &#125; //更新 public static void updateEmp() &#123; SessionFactory sessionFactory= MySessionFactory.getSessionFactory(); Session session=sessionFactory.openSession(); //修改一个雇员,先得到，再修改 Transaction ts=session.beginTransaction(); //load方法是用于获取 指定 主键的对象（记录.） Employee emp=(Employee)session.load(Employee.class, 1); emp.setName(\"小名\"); ts.commit(); &#125; //修改雇员 //添加一个雇员 private static void addEmpoyee() &#123; //1.得到Configuration Configuration configuration= new Configuration().configure(); //2.得到SessionFactory(会话工厂，这是一个重量级的类，因此要保证在一个应用程序中只能有一个) SessionFactory sessionFactory=configuration.buildSessionFactory(); //3. 从SessionFactory中取出一个Session对象(它表示 和数据库的出一次会话) Session session=sessionFactory.openSession(); //4. 开始一个事务 Transaction transaction = session.beginTransaction(); //保存一个对象到数据库(持久化一个对象) Employee emp=new Employee(); emp.setEmail(\"kk@sohu.com\"); emp.setHiredate(new java.util.Date()); emp.setName(\"shunping\"); //不要给id,因为它是自增的 session.save(emp);//insert into employee (name,id,...) value(?,?,?) transaction.commit(); &#125;&#125;","tags":[{"name":"web","slug":"web","permalink":"http://limao777.github.io/blog/tags/web/"},{"name":"数据库","slug":"数据库","permalink":"http://limao777.github.io/blog/tags/数据库/"}]},{"title":"gcc相关概念","date":"2017-10-25T08:03:21.000Z","path":"cjq6eersj0000loutbfpx0c2b.html","text":"gcc工作流程预处理 –E 宏替换 头文件展开 注释去掉 XXX.c -&gt; xxx.i 编译 –Sxxx.i -&gt; xxx.s汇编文件 汇编 -cxxx.s -&gt; xxx.o二进制文件 链接xxx.o -&gt; xxx（可执行） gcc常用参数显示版本-v/–version 编译的时候指定头文件路径-I {文件路径} 指定编译出来的文件名字-o {文件名} 汇编文件生成二进制文件-c：最终得到一个.o文件 使用gdb调试-g 编译的时候指定一个宏-D //主要是测试程序的时候用e.g.123gcc hello.c -D DEBUG -o hello//\"-D DEBUG\"相当于C代码中加上了如下一行：#define DEBUG 编译时添加警告信息，即有警告也会在编译时提示-wall 优化代码-On：n是优化级别：1，2，3 静态库的制作和使用命名规则：libxxx.a(通常只有xxx自定义) 制作步骤 原材料：源代码 将.c文件生成.o：gcc abc.c def.c -c 将.o文件打包：使用ar，e.g. ar rcs libtest.a *.o(将当前目录所有.o打包为mytest.a，之后可以用nm libtest.a查看打包后包含的方法)e.g.1234567891011121314151617181920212223head.h文件：#ifndef __HEAD_H_#define __HEAD_H_int add (int a, int b);#endifabc.c文件：#include \"head.h\"int add (int a, int b)&#123; int res = a + b; return res;&#125;main.c文件：#include &lt;stdio.h&gt;#include \"head.h\"int main(void)&#123; int sum = add(1,2); printf(\"%d\\n\",sum); return 1;&#125; 静态库使用使用-L参数指定静态库路径使用-l指定静态路名字e.g.1gcc main.c -L ./lib -l test -o main 动态库的制作和使用(ldd {文件名}可以查看应用程序依赖库的路径)命名规则libxxx.so 制作步骤 将源文件生成.o gcc a.c b.c -fpic(fPIC) 打包gcc shared a.o b.o -0 ;ibxxx.so ###库的使用 头文件a.h 动态库 libtest.so参考函数声明编程测试程序main.cgcc main.c -I ./ -L ./ -l test -o app 动态库加载失败的问题对于elf格式的程序（使用file app查看），是由ld-linux.so*来完成（用ldd app查看），先后搜索elf文件的DT-RPATH段 - 环境变量LD_LIBRARY_PATH - /etc/ld.so.cache文件列表 - /lib，/usr/lib目录找到库文件后将其载入内存所以如果要用我们自己的库，则需用以下方法： 拷贝自己制作的共享库到/lib或/usr/lib 临时设置LD_LIBRARY_PATH 1export LD_LIBRARY_PATH=库路经:$LD_LIBRARY_PATH 永久设置用户级别：~/.bashrc加上上述命令，并使用source ~/.bashrc重启终端系统级别：1./etc/profile加上上述命令，并使用source /etc/profile重启终端2./etc/ld.so.cache文件列表，找到一个配置文件/etc/ld.so.conf把动态库绝对路i经添加到文件中，再执行sudo ldconfig -v","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"编译技术","slug":"编译技术","permalink":"http://limao777.github.io/blog/tags/编译技术/"}]},{"title":"linux vim详解","date":"2017-10-25T02:38:28.000Z","path":"cjq6eersv0007lout366ne1kg.html","text":"直接在bash中使用vim教学1vimtutor vim的三种工作模式 命令模式(打开文件默认先进入命令模式) 编辑模式 末行模式(行跳转、查询、退出等) 命令模式相关保存退出ZZ 代码格式化gg=G 光标的移动 上下左右：HJKL（分别对应左下上右） 光标移动到行首0（零） 光标移动到行尾$ 光标移动到文件首部gg 光标移动到文件尾部G 跳转到123行123G或123gg另外输入行号n按下回车：当前行向下移动n行 删除命令(本质上是剪切操作) 删除光标前的字符：X 删除光标后的字符：x 删除单词：dw，删除整个单词光标应该在单词的最前边 删除光标前字符串：d0 删除光标后字符串：d$(D) 删除光标所在行：dd 删除多行：{数字}dd（从当前光标处下数n行） 撤销反撤销 撤销：u 反撤销：ctrl+r 复制粘贴 复制一行：yy 复制多行：{数字}yy p(小写)：粘贴到光标的下边一行 P(大写)：粘贴到光标的上边一行 可视模式：v 移动光标：hjkl（大多电脑上下左右也行） 复制：y 删除：d 粘贴：p(小写)：粘贴到光标的后边，P(大写)：粘贴到光标前边 查找/{查找关键字}，切换按n（向下）/N（向上），向下搜索？{查找关键字}，切换按n（向下）/N（向上），向上搜索 #：光标移动到待搜索单词上边，再按# 命令模式切换到编辑模式 a：从光标后开始插入字符 A：行尾插入字符 i：光标前插入字符 I：行首插入字符 o：光标下创建新行 O：光标上创建新行 s：删除光标盖住的字符 S：删除光标所在行 切换回命令模式ESC 末行模式相关保存不退出:w 保存退出:wq或:x 光标跳到n行:n(n是数字) 未修改退出:q 放弃修改退出:q! 显示/取消显示行号:set nu //显示:set nu! //不显示 字符串替换:s/{被替换值}/{新替换值} //替换当前一个:s/{被替换值}/{新替换值}/g //直接替换当前行所有的:s/{被替换值}/{新替换值}/gc //直接替换当前行所有的并每一个都确认:22,28s/{被替换值}/{新替换值}[/gc] //替换22-28行:%s/{被替换值}/{新替换值}[/gc] //替换整个文本 一个文件分屏:sp //水平分屏:vsp //垂直分屏 多文件分屏:vsp {文件}:sp {文件} 打开的时候分屏12vim -o &#123;文件名&#125; &#123;文件名&#125; ... //水平分多个屏vim -O &#123;文件名&#125; &#123;文件名&#125; &#123;文件名&#125; ... //垂直分多个屏 分屏切换ctrl+w两次：分屏切换 分屏的退出:qall //全部退出:wall //保存所有的:wqall //保存并退出所有的 执行shell命令:!{shell命令}e.g.1:!pwd vim配置文件配置文件位置 用户级别：~/.vimrc 系统级别：/etc/vim/vimrc或/etc/vimrc","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"}]},{"title":"linux压缩和解压缩相关技术","date":"2017-10-24T08:33:42.000Z","path":"cjq6eersx000aloutn6eqzshs.html","text":"linux下常见的压缩格式 .gz –gzip .bz2 -bzip2 常用压缩命令tar打包参数： c：创建压缩文件 x：释放压缩文件 v：打印提示信息 f：指定压缩包名字 z：使用gzip压缩文件 j：使用bzip2的方式压缩文件 压缩 tar 参数 压缩包名字 原材料12tar zcvf aaa.tar.gz ./data //打包并压缩./data下的文件tar zcvf aaa.tar.gz abc def ./data //打包并压缩./data下的文件以及abc、def文件(或目录) 解压缩 tar 参数 压缩包名字 -C 解压目录12tar zxvf aaa.tar.gztar zxvf aaa.tar.gz -C /tmp/aaa rarrar需要安装1sudo apt-get install rar 压缩rar a 压缩包名(不用指定后缀) 压缩内容 解压缩rar x 压缩包名 解压目录 zip/unzip压缩zip 参数 压缩包名 原材料如果有目录，加上参数r 解压缩unzip 压缩包名 -d 解压目录","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"}]},{"title":"linux bash find命令详解","date":"2017-10-24T07:55:00.000Z","path":"cjq6eersu0006lout8ha4u5xh.html","text":"按文件查找find 查找的目录 -name “查找的文件名”e.g.12find . -name \"hachi\"find . -name \"*\" //查找当前目录下的所有文件 按文件类型查找find 查找目录 -type 文件类型 普通文件：f 目录：d 符号链接：l 管道：p 套接字：s 字符设备：c 块设备：be.g. 1find ./ -type d //列出目录 按文件大小查找find 查找的目录 -size [+-]{单位}单位：k：小写M：大写e.g.12find ./ -size +100k //查找当前目录大于100k的文件，包含子目录find ./ -size +100k -size -10M //查找当前目录大于100k，小于10M的文件，包含子目录 按照日期查找 创建日期：-ctime -n/+n (-n：n天以内，+n：n天以外) 修改日期：-mtime 访问时间：-atimee.g. 1find ./ -ctime -1 //查找1天以内创建的文件 按深度查找find 查找的目录 [-maxdepth -mindepth] 搜索深度 maxdepth：n层以内的目录 mindepth：至少n层以上的目录e.g. 1find ./ -maxdepth 3 -name \"hachi\" //查找3层目录以内的hachi文件 结合其他bash命令用法123find ./ -type d -exec ls -l &#123;&#125; \\; //查找当前目录并列出详细信息find ./ -type d -ok ls -l &#123;&#125; \\; //查找当前目录并列出详细信息，每执行一个会询问是否继续find ./ -type d | xargs ls -l //查找当前目录并列出详细信息，这种效率比较高 根据文件内容查找 -grepgrep -r (有子目录) “查找的内容” 搜索的路径e.g.12grep -r \"hachi\" ./ //查找当前目录中带hachi字符串的文件grep -r \"hachi\" ~ -n //查找home目录中带hachi字符串的文件，并显示查出来的字符串在第多少行","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"}]},{"title":"java操作文件的几种方法","date":"2017-10-20T01:18:33.000Z","path":"cjq6eersp0002loutyq7cn0pk.html","text":"流式方式写入文件(使用字节)123456789101112131415161718192021/** * 流式方式写入文件(使用字节) * @param path */public static void writeFileUsingByte(String path)&#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(new File(path)); fos.write(\"aaaaa\\r\\nbbb\".getBytes()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 流式方式读取文件(使用字符)123456789101112131415161718192021222324252627/** * 流式方式读取文件(使用字符) * @param path */public static void readFileUsingByte(String path) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream(new File(path)); byte []bytes = new byte[1024]; int n = 0; while((n=fis.read(bytes))!=-1)&#123; String s = new String(bytes,0,n); System.out.println(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 流式方式读取文件(使用字符)123456789101112131415161718192021222324252627/** * 流式方式读取文件(使用字符) * @param path */public static void readFileUsingByte(String path) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream(new File(path)); byte []bytes = new byte[1024]; int n = 0; while((n=fis.read(bytes))!=-1)&#123; String s = new String(bytes,0,n); System.out.println(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 读出文件并写入到另外的文件中（使用字符）123456789101112131415161718192021222324252627282930/** * 读出文件并写入到另外的文件中（使用字符） * @param path */public static void dealFileUsingChar(String readPath, String writePath)&#123; FileReader fr = null; FileWriter wr = null; int n=0; try &#123; fr = new FileReader(readPath); wr = new FileWriter(writePath); char []c=new char[1024]; while((n=fr.read(c))!=-1)&#123; String s = new String(c,0,n); System.out.println(s); wr.write(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fr.close(); wr.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 读出文件并写入到另外的文件中（使用缓冲）123456789101112131415161718192021222324252627282930/** * 读出文件并写入到另外的文件中（使用缓冲） * @param readPath * @param writePath */public static void dealFileUsingBufferedReader(String readPath, String writePath) &#123; BufferedReader br = null; BufferedWriter wr = null; try &#123; br = new BufferedReader(new FileReader(readPath)); wr = new BufferedWriter(new FileWriter(writePath)); String s=\"\"; while((s=br.readLine())!=null)&#123; System.out.println(s); wr.write(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; br.close(); wr.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;","tags":[{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"}]},{"title":"使用hexo和X-pages搭建个人博客实践","date":"2017-10-13T08:36:55.000Z","path":"cjq6eert1000floutfq1gj0a2.html","text":"才将基于github pages的博客系统搭建好，趁热先写写搭建过程中的一些过程，hexo是一个快速、简洁且高效的博客框架，能生成静态页面 前提 安装好nodejs 安装好git nodejs安装进入nodejs官方网站，直接下载安装包安装即可 git安装git也是比较好安装的，git官网下载git软件直接安装好即可，git官网是https://git-scm.com/ 本地化搭建本地化搭建将按照如下方式组织文章 安装hexo 初始化hexo 配置hexo 新增文章 生成静态页面 本地预览 安装hexo1npm install hexo-cli -g 初始化hexo在准备写博客的文件夹处使用命令：12hexo initnpm install 此时将完成了hexo的初始化，如果一切默认配置则可以写文章了，通常我们要简单配置一下hexo 配置hexo通常要配置的选项位于你建立博客根目录的_config.yml文件必要的变更包括# Site、# URL，其他的则可以根据自身需要进行配置其中# Site的配置关于language和timezone比较特殊，都不是随意配置的，须符合一定的language和timezone规则，如language通常配置zh-CN、en等，timezone则配置Asia/Shanghai，这些可以通过搜索引擎搜索Unix的locale语言以及timezone可选的配置如果网站存放在子目录中，例如 http://yoursite.com/blog，则请将 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/最后建立一个about.html文件，通常很多主题模版需要这个文件，hexo中要手动建立一个：1hexo new page 'about' 新增文章使用以下命令创建一篇新文章1hexo new '文章标题' 通过这个命令则在_posts文件夹下面建立了一个文件，该文件使用markdown进行编写，最后生成出来的就是你的博客了 生成静态页面1hexo g 此时public文件夹就是你的博客的静态文件了，可以上传到支持静态文件加载的地方，这样大家就能欣赏你的博客了 本地预览1hexo server 直接使用该命令即可启动本地服务器，照着提示浏览器访问那个端口就即可。如果不嫌麻烦，也可以使用apache、nginx指向public文件夹，效果是一样的 将博客上传到互联网 建立gitpages 代码上传到github 建立gitpages当然，你得有一个github帐号，国内的如码云等git托管网站也有类似的功能在github上建立一个和你名字一模一样的工程，选择该工程的配置，点击pages，点击生成即可，默认的访问方式就是{你的名字}.github.io 代码上传到github1git clone &#123;你的项目&#125; 再复制你的public文件夹到你的git项目中，如果使用了子目录则相应地建立子目录123git add --allgit commit -m 'update blog'git push origin &#123;你的项目&#125; 一些小技巧直接在hexo中使用静态文件在hexo3中，静态文件可通常的markdown格式不一样，可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开打开过后每次新增文章则会相应地在_posts文件夹下建立静态资源目录，将静态资源目录放进去即可，引用方式：12345&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;e.g. &#123;% asset_img example.jpg 这里是alt标签 %&#125; 使用category和tagse.g.123456789---title: testdate: 2017-10-13 13:58:50category: ABCtags:- tag1- tag2- tag3---","tags":[{"name":"git","slug":"git","permalink":"http://limao777.github.io/blog/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://limao777.github.io/blog/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://limao777.github.io/blog/tags/博客/"}]}]