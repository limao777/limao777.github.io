[{"title":"开发一个新框架-Hachi","date":"2018-04-12T02:17:11.000Z","path":"cjfvw8ja20016u0cne63nqas0.html","text":"&emsp;&emsp;近几年陆续开发了一些Web应用和其他应用，需求或简单或复杂，实现或优雅或丑陋。一个基本的事实是：只是积累了一些经验或提高了对编程语言以及涉及到的开发业务的熟悉程度。&emsp;&emsp;随着软件开发经验的不断增加，其实很多工作都是重复机械的,框架是实现了某应用领域通用功能的底层服务。使用这种框架的编程人员可以在一个通用功能已经实现的基础上开始具体的系统开发。框架提供了所有应用期望的默认行为的类集合。具体的应用通过重写子类或组装对象来支持应用专用的行为。通俗的说，框架是完成是某种应用的半成品，提供了一些常用的工具类和一些基础通用化的组件，可以供开发人员在此基础上，更便捷的完成各自特有的系统。&emsp;&emsp;开发一个系统时，我们不可避免的会使用各种框架：数据层、路由曾、日志、长连接、自动映射等。一个高质量的软件系统往往还有全局容错，消息队列等组件。把上述这些组件组合到一起的时候，其复杂度会急剧上升。&emsp;&emsp;其实，我们无非是希望在编程的时候，把大部分的注意力全部集中到业务实现上。不要过多的考虑基础的软件结构上的种种问题，应该有一个框框或者一种范式来提供基本的服务。&emsp;&emsp;现有的PHP框架较为流行的如TP、YII、CI、yaf等，但均适用于网页型的开发，但是大规模开发中通常后端开发有很多场景：&emsp;&emsp;以CMCC IOTEAM团队的后端开发为例，大体如下： 网页/后台管理开发（php-yaf） 短连接API开发（php-yaf） TCP/UDP服务（php-swoole） 异步队列/api（php-swoole） 多线程/进程并发（php-pcntl） 定时任务（crontab）&emsp;&emsp;一个很明确的事情就是在这样的团队中一个后端开发就需招聘擅长不同框架语言的程序员来开发，维护性大打折扣！&emsp;&emsp;稍微正规一点的公司经过多年沉淀都形成了自己的内部软件框架，他们在开发软件的时候并不是从一片空白开始的。而是从一个非常牢固的基础平台上开始构建的。这样大大提高了开发速度。基于此，距今大约一年的样子，在2017年4月份开发出了PHP-HACHI框架，只需要一个框架就可完成上述所有开发。&emsp;&emsp;它并没有使用任何新的技术，只是将一些东西整合到了一起，并提供了一个不复杂也不轻量的路由、一个统一的上下文结构以支持不变更代码即可通用cgi部署和传统的FPM部署、自动加载器、cgi部署管理器以及一个简单的不能再简单的日志类。&emsp;&emsp;框架发布已经一年，团队内部也使用它做了好几个项目了，从一开始的OneNET触屏版项目强制使用cgi部署导致了原有熟悉fpm开发模式的PHPer各种不适应到后面系统监控报警系统大大地感受到了cgi部署带来的诸如TCP监听、定时任务的带来的极大开发方便，再到最后面几个经典的网站应用项目也从yaf变更到了hachi，最重要的两个指标的安全性、稳定性算是基本通过了考验。&emsp;&emsp;后续还会对框架进行大规模更新甚至重构，最后希望达到的效果就是如果是基于PHP开发，只用一个框架就解决问题。https://github.com/limao777/Hachi-PHP-Framework","tags":[{"name":"web","slug":"web","permalink":"http://limao777.github.io/blog/tags/web/"},{"name":"架构","slug":"架构","permalink":"http://limao777.github.io/blog/tags/架构/"}]},{"title":"线程相关概念以及pthread","date":"2017-11-16T06:02:07.000Z","path":"cjfvw8je4001iu0cno4qic7k5.html","text":"几个知识点创建线程之后，地址空间没有变化进程退出成了线程-主线程主线程和子线程有各自独立的pcb（子线程的pcb是从主线程拷贝来的）在linux下，线程就是轻量级进程（内核看pcb） 主线程和子线程共享的数据.text(代码段).bss（未初始化的变量）.data（已初始化的变量）堆动态库家再去环境变量命令行参数– 线程间通信可以依靠全局变量、堆 主线程和子线程不共享的数据栈(栈区被线程平均分配) （补充）进程间共享的资源代码文件描述符内存映射区 – mmap 查看指定线程的LWP号ps -Lf {pid}注意线程号和进程ID是有区别的，线程号给内核看 线程相关函数创建线程函数原型12345678//如果成功返回0，失败返回错误号//perror()不能使用该函数打印错误信息，它只是个数字itn pthread_create(pthread_t *thread, //线程ID=无符号长整型const pthread_attr_t *attr, //线程属性，通常为NULLvoid *(*start_routine) (void *), //线程处理函数void *arg //线程处理函数参数); 参数 thread：创出参数，线程创建成功以后，会被设置一个合适的值 attr：默认传NULL start_routine：子线程的处理函数 arg：回调函数的参数主线程先退出，子线程会被强制结束 单个线程退出函数原型1void pthread_exit(void *retval); 阻塞等待线程退出，获取线程退出状态函数原型1int pthread_join(pthread_t thread, void **retval); 线程分离函数原型1int pthread_detach(pthread_t thread); 调用该函数后不需要pthread_join()，子线程会自动回收自己的PCB 杀死（取消）线程函数原型1int pthread_cancel(pthread_t thread); 在要杀死的子线程对应的处理函数的内部必须做过一次系统调用 简单的e.g.123456789101112131415161718192021222324252627282930//gcc编译时参数加上 -lpthrad#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;void* myfunc(void* arg)&#123; int num = *(int*)arg; printf(\"%dth child thread id:%ld\\n\", num, pthread_self()); return NULL;&#125;int main(int argc, const char* argv[])&#123; //创建一个子线程 int i = 0; pthread_t pthid[5]; for(i=0;i&lt;5;++i)&#123; pthread_create(&amp;pthid[i], NULL, myfunc, (void*)&amp;i); //此处用的引用传递，会导致多线程的i有可能取到同一个 &#125; printf(\"parent thread id:%ld\\n\", pthread_self()); for(i=0;i&lt;5;i++)&#123; printf(\"i=%d\\n\",i); &#125; sleep(2); return 0;&#125;","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"C语言","slug":"C语言","permalink":"http://limao777.github.io/blog/tags/C语言/"}]},{"title":"用C语言创建一个守护进程并使用定时器","date":"2017-11-14T07:10:58.000Z","path":"cjfvw8ja90018u0cnuprsu63m.html","text":"守护进程的特点 后台服务进程 独立于控制终端 周期性执行某任务 不受用户登陆注销影响 一般采用以d结尾的名字（服务） 进程组进程组组长一般是组里面第一个进程进程组的ID==进程组组长的ID 会话 - 多个进程组创建一个会话注意事项不能是进程组长创建会话的进程成为新进程组的组长有些linux版本需要root权限执行次操作（ubuntu不需要）创建出的新会话会丢弃原有的控制终端一般步骤：先fork，父进程死，子进程执行创建会话操作 获取进程所属的会话IDpid_t getsid(pid_t pid); 创建一个会话pid_t setsid(void); ##创建守护进程模型fork子进程，父进程退出子进程创建新会话改变当前工作目录chdir重设文件掩码关闭文件描述符执行核心工作 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;void dowork(int no)&#123; time_t curtime; //get current sys time and write it to file time(&amp;curtime); //format time char *pt = ctime(&amp;curtime); int fd = open(\"/tmp/aaaaattt.txt\", O_CREAT | O_WRONLY | O_APPEND, 0644); write(fd, pt, strlen(pt)+1); close(fd);&#125;int main(int argc, const char* argv[])&#123; pid_t pid = fork(); if(pid&gt;0)&#123; exit(1); &#125; else if(pid==0)&#123; setsid(); //改变进程工作目录 chdir(\"/tmp\"); //配置文件掩码 umask(0); //关闭文件描述符 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); //执行核心操作，注册信号捕捉 struct sigaction act; act.sa_handler = 0; act.sa_handler = dowork; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); //创建定时器 struct itimerval val; //首次触发时间 val.it_value.tv_usec = 0; val.it_value.tv_sec = 2; //循环周期 val.it_interval.tv_usec = 0; val.it_interval.tv_sec = 1; setitimer(ITIMER_REAL, &amp;val, NULL); while(1); &#125; return 0;&#125;","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"C语言","slug":"C语言","permalink":"http://limao777.github.io/blog/tags/C语言/"}]},{"title":"makefile相关概念","date":"2017-10-30T07:37:46.000Z","path":"cjfvw8ja80017u0cnqaxycwew.html","text":"make一个概念：gcc -&gt; 编译器make -&gt; linux自带的构建器，构建的规则在makefile中 makefile文件的命名 makefile、Makefile两者均可 makefile中的规则如：gcc a.c b.c c.c -o app分为三个部分：目标、依赖、命令（makefile文件中）使用目标：依赖（换行）（tab缩进）命令： 第一个版本的编写12app:a.c b.c c.c&#123;TAB&#125;gcc a.c b.c c.c -o app 然后执行make命令即可 第二个版本的编写，优化编译原理： 检测依赖是否存在：向下搜索下边的规则，如果有规则是用来生成查找依赖的，执行规则中的命令 依赖存在：判断是否需要更新，原则：目标时间&gt;依赖时间，反之，则更新1234567891011app:a.o b.o c.o&#123;TAB&#125;gcc a.o b.o c.o -o appa.o:a.c&#123;TAB&#125;gcc a.c -cb.o:b.c&#123;TAB&#125;gcc b.c -cc.o:c.c&#123;TAB&#125;gcc c.c -c 第三个版本自定义变量(通常用小写):obj=a.o b.o c.oobj=10变量的取值：aa=$(obj)makefile自带的变量：大写 CPPFLAGS CC自动变量： $@：规则中的目标 $&lt;：规则中的第一个依赖 $^：规则中所有的依赖自动变量只能在规则中的命令中使用1234567obj = a.o b.o c.otarget = app$(target):$(obj)&#123;TAB&#125;gcc $(obj) -o $(target)%.o:%.c&#123;TAB&#125;gcc -c $&lt; -o $@ 模式匹配：%.o:%.c第一次：a.o没有%就匹配了a，变成了gcc -c a.c -o a.o第二次和第三次类似 第四个版本，解决可移植性比较差的问题先介绍几个函数： 查找指定目录下指定类型的文件：wildcard #e.g. src = $(wildcard ./*.c) //空格后面加上参数 匹配替换：patsubst #e.g. obj = $(patsubst %.c,%.o,$(src)) //匹配用百分号，将src中的.c替换为.o12345678src = $(wildcard ./*.c)obj = $(patsubst %.c,%.o,$(src))target = app$(target):$(obj)&#123;TAB&#125;gcc $(obj) -o $(target) #或gcc $^ -o $@%.o:%.c&#123;TAB&#125;gcc -c $&lt; -o $@ 第五个版本，带自动清理项目即让make生成不是终极目标的目标123456789101112src = $(wildcard ./*.c)obj = $(patsubst %.c,%.o,$(src))target = app$(target):$(obj)&#123;TAB&#125;gcc $(obj) -o $(target) #或gcc $^ -o $@%.o:%.c&#123;TAB&#125;gcc -c $&lt; -o $@.PHONY:CLEAN #声明clean为为目标，使clean不受文件爱你更新检查的干扰clean:&#123;TAB&#125;-rm $(obj) $(target) -f #&quot;-&quot;表示如果执行失败继续执行后面的，-f是rm的参数，强制执行不报错 执行make clean即可","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"},{"name":"编译技术","slug":"编译技术","permalink":"http://limao777.github.io/blog/tags/编译技术/"}]},{"title":"hibernate介绍与快速入门","date":"2017-10-30T02:11:35.000Z","path":"cjfvw8is40000u0cne64ikm20.html","text":"应用场景一个数据库框架，使用hibernate后可以使用hql语句操作数据库，如果涉及到数据库迁移等则无需改代码，使开发人员更关注业务本身 快速入门hibernate和structs说明hibernate可以用在j2se和j2ee中，而struts是web框架，一般用于j2ee项目 开发流程创建一个项目引入hibernate开发包从网上下载 开发的三种方式 由Domain object -&gt; mapping -&gt; db（官方推荐） 由DB开始，用工具生成mapping和Domain object（使用较多） 由映射文件开始 使用第二种方式开发项目 创建表和序列(使用oracle) 1234567891011121314create table employee(id number primary key,name varchar2(64) not null,email varchar(64) not null,hiredate date not null);create sequence emp_seq(start with 1,increment by 1,min value 1,nomaxvalue,nocycle,nocache,); 开发domain对象和对象映射文件，用于指定domain对象和表的映射关系，该文件取名有规范：domain对象.hbm.xml，一般放在和domain对象同一个文件夹下 12345678910111213141516171819202122232425262728293031323334353637383940//package com.lm.domainimport java.io.Serializable;//domain对象那个名称就是对应首字母的大写//domain对象，也叫javabean或pojo(plain ordinary java objects)public class Employee implements Serializable&#123; /** * */ private static final long serialVersionUID = 1L; private Integer id; private String name; private String email; private java.util.Date hiredate; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public java.util.Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(java.util.Date hiredate) &#123; this.hiredate = hiredate; &#125;&#125; 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- package : 表示该类在哪个包下 --&gt;&lt;hibernate-mapping package=\"com.lm.domain\"&gt;&lt;!-- name : 表示类名 table 表示 该类和哪个表映射 --&gt; &lt;class name=\"Employee\" table=\"employee\"&gt; &lt;!-- id元素专门用于指定主键是如何生成,hibernate设计者认为，我们每一个表都应该有一个主键 --&gt; &lt;!-- name:表示类的哪个属性是主键 --&gt; &lt;id name=\"id\" type=\"java.lang.Integer\"&gt; &lt;!-- 指定主键生成策略 --&gt; &lt;generator class=\"sequence\"&gt; &lt;param name=\"sequence\"&gt;emp_seq&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\" type=\"java.lang.String\"&gt; &lt;column name=\"name\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;property name=\"email\" type=\"java.lang.String\"&gt; &lt;column name=\"email\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;property name=\"hiredate\" type=\"java.util.Date\"&gt; &lt;column name=\"hiredate\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 手动配置hibernate.cfg.xml文件（文件名一般不用改，但是也可以改成其他名字），该文件用于配置连接数据库的类型,driver、用户名、密码等，位于src根目录 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;&lt;!-- 该文件用于配置连接数据的种类,用户名，密码,ul ,驱动.. 连接池,二级缓存.. 有点类似strus struts-config.xml --&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"connection.driver_class\"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:oracle:thin:@127.0.0.1:1521:orclhsp&lt;/property&gt; &lt;property name=\"connection.username\"&gt;scott&lt;/property&gt; &lt;property name=\"connection.password\"&gt;tiger&lt;/property&gt; &lt;!-- 配置显示hibernate生成的 sql ,特别说明，在开发阶段设为true利于调试，在使用项目则设为false--&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!-- 配置数据库的方言/ --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt; &lt;!-- 配置管理的对象映射文件 --&gt; &lt;mapping resource=\"com/hsp/domain/Employee.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.lm.view;import java.sql.Date;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.lm.domain.Employee;import com.lm.utils.MySessionFactory;public class TestMain &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub SessionFactory sessionFactory= MySessionFactory.getSessionFactory(); Session session=sessionFactory.openSession(); //查询可以不使用事务 Employee emp=(Employee) session.load(Employee.class, 3); System.out.println(emp.getName()+\" \"+emp.getEmail()); session.close(); &#125; public static void delEmp() &#123; // TODO Auto-generated method stub SessionFactory sessionFactory= MySessionFactory.getSessionFactory(); Session session=sessionFactory.openSession(); //删除一个雇员,先得到，再修改 Transaction ts=session.beginTransaction(); Employee emp=(Employee) session.load(Employee.class, 2); session.delete(emp); ts.commit(); &#125; //更新 public static void updateEmp() &#123; SessionFactory sessionFactory= MySessionFactory.getSessionFactory(); Session session=sessionFactory.openSession(); //修改一个雇员,先得到，再修改 Transaction ts=session.beginTransaction(); //load方法是用于获取 指定 主键的对象（记录.） Employee emp=(Employee)session.load(Employee.class, 1); emp.setName(\"小名\"); ts.commit(); &#125; //修改雇员 //添加一个雇员 private static void addEmpoyee() &#123; //1.得到Configuration Configuration configuration= new Configuration().configure(); //2.得到SessionFactory(会话工厂，这是一个重量级的类，因此要保证在一个应用程序中只能有一个) SessionFactory sessionFactory=configuration.buildSessionFactory(); //3. 从SessionFactory中取出一个Session对象(它表示 和数据库的出一次会话) Session session=sessionFactory.openSession(); //4. 开始一个事务 Transaction transaction = session.beginTransaction(); //保存一个对象到数据库(持久化一个对象) Employee emp=new Employee(); emp.setEmail(\"kk@sohu.com\"); emp.setHiredate(new java.util.Date()); emp.setName(\"shunping\"); //不要给id,因为它是自增的 session.save(emp);//insert into employee (name,id,...) value(?,?,?) transaction.commit(); &#125;&#125;","tags":[{"name":"web","slug":"web","permalink":"http://limao777.github.io/blog/tags/web/"},{"name":"数据库","slug":"数据库","permalink":"http://limao777.github.io/blog/tags/数据库/"}]},{"title":"gcc相关概念","date":"2017-10-25T08:03:21.000Z","path":"cjfvw8ish0007u0cnaqhzq05d.html","text":"gcc工作流程预处理 –E 宏替换 头文件展开 注释去掉 XXX.c -&gt; xxx.i 编译 –Sxxx.i -&gt; xxx.s汇编文件 汇编 -cxxx.s -&gt; xxx.o二进制文件 链接xxx.o -&gt; xxx（可执行） gcc常用参数显示版本-v/–version 编译的时候指定头文件路径-I {文件路径} 指定编译出来的文件名字-o {文件名} 汇编文件生成二进制文件-c：最终得到一个.o文件 使用gdb调试-g 编译的时候指定一个宏-D //主要是测试程序的时候用e.g.123gcc hello.c -D DEBUG -o hello//\"-D DEBUG\"相当于C代码中加上了如下一行：#define DEBUG 编译时添加警告信息，即有警告也会在编译时提示-wall 优化代码-On：n是优化级别：1，2，3 静态库的制作和使用命名规则：libxxx.a(通常只有xxx自定义) 制作步骤 原材料：源代码 将.c文件生成.o：gcc abc.c def.c -c 将.o文件打包：使用ar，e.g. ar rcs libtest.a *.o(将当前目录所有.o打包为mytest.a，之后可以用nm libtest.a查看打包后包含的方法)e.g.1234567891011121314151617181920212223head.h文件：#ifndef __HEAD_H_#define __HEAD_H_int add (int a, int b);#endifabc.c文件：#include \"head.h\"int add (int a, int b)&#123; int res = a + b; return res;&#125;main.c文件：#include &lt;stdio.h&gt;#include \"head.h\"int main(void)&#123; int sum = add(1,2); printf(\"%d\\n\",sum); return 1;&#125; 静态库使用使用-L参数指定静态库路径使用-l指定静态路名字e.g.1gcc main.c -L ./lib -l test -o main 动态库的制作和使用(ldd {文件名}可以查看应用程序依赖库的路径)命名规则libxxx.so 制作步骤 将源文件生成.o gcc a.c b.c -fpic(fPIC) 打包gcc shared a.o b.o -0 ;ibxxx.so ###库的使用 头文件a.h 动态库 libtest.so参考函数声明编程测试程序main.cgcc main.c -I ./ -L ./ -l test -o app 动态库加载失败的问题对于elf格式的程序（使用file app查看），是由ld-linux.so*来完成（用ldd app查看），先后搜索elf文件的DT-RPATH段 - 环境变量LD_LIBRARY_PATH - /etc/ld.so.cache文件列表 - /lib，/usr/lib目录找到库文件后将其载入内存所以如果要用我们自己的库，则需用以下方法： 拷贝自己制作的共享库到/lib或/usr/lib 临时设置LD_LIBRARY_PATH 1export LD_LIBRARY_PATH=库路经:$LD_LIBRARY_PATH 永久设置用户级别：~/.bashrc加上上述命令，并使用source ~/.bashrc重启终端系统级别：1./etc/profile加上上述命令，并使用source /etc/profile重启终端2./etc/ld.so.cache文件列表，找到一个配置文件/etc/ld.so.conf把动态库绝对路i经添加到文件中，再执行sudo ldconfig -v","tags":[{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"编译技术","slug":"编译技术","permalink":"http://limao777.github.io/blog/tags/编译技术/"}]},{"title":"linux vim详解","date":"2017-10-25T02:38:28.000Z","path":"cjfvw8is90002u0cnkarti9to.html","text":"直接在bash中使用vim教学1vimtutor vim的三种工作模式 命令模式(打开文件默认先进入命令模式) 编辑模式 末行模式(行跳转、查询、退出等) 命令模式相关保存退出ZZ 代码格式化gg=G 光标的移动 上下左右：HJKL（分别对应左下上右） 光标移动到行首0（零） 光标移动到行尾$ 光标移动到文件首部gg 光标移动到文件尾部G 跳转到123行123G或123gg另外输入行号n按下回车：当前行向下移动n行 删除命令(本质上是剪切操作) 删除光标前的字符：X 删除光标后的字符：x 删除单词：dw，删除整个单词光标应该在单词的最前边 删除光标前字符串：d0 删除光标后字符串：d$(D) 删除光标所在行：dd 删除多行：{数字}dd（从当前光标处下数n行） 撤销反撤销 撤销：u 反撤销：ctrl+r 复制粘贴 复制一行：yy 复制多行：{数字}yy p(小写)：粘贴到光标的下边一行 P(大写)：粘贴到光标的上边一行 可视模式：v 移动光标：hjkl（大多电脑上下左右也行） 复制：y 删除：d 粘贴：p(小写)：粘贴到光标的后边，P(大写)：粘贴到光标前边 查找/{查找关键字}，切换按n（向下）/N（向上），向下搜索？{查找关键字}，切换按n（向下）/N（向上），向上搜索 #：光标移动到待搜索单词上边，再按# 命令模式切换到编辑模式 a：从光标后开始插入字符 A：行尾插入字符 i：光标前插入字符 I：行首插入字符 o：光标下创建新行 O：光标上创建新行 s：删除光标盖住的字符 S：删除光标所在行 切换回命令模式ESC 末行模式相关保存不退出:w 保存退出:wq或:x 光标跳到n行:n(n是数字) 未修改退出:q 放弃修改退出:q! 显示/取消显示行号:set nu //显示:set nu! //不显示 字符串替换:s/{被替换值}/{新替换值} //替换当前一个:s/{被替换值}/{新替换值}/g //直接替换当前行所有的:s/{被替换值}/{新替换值}/gc //直接替换当前行所有的并每一个都确认:22,28s/{被替换值}/{新替换值}[/gc] //替换22-28行:%s/{被替换值}/{新替换值}[/gc] //替换整个文本 一个文件分屏:sp //水平分屏:vsp //垂直分屏 多文件分屏:vsp {文件}:sp {文件} 打开的时候分屏12vim -o &#123;文件名&#125; &#123;文件名&#125; ... //水平分多个屏vim -O &#123;文件名&#125; &#123;文件名&#125; &#123;文件名&#125; ... //垂直分多个屏 分屏切换ctrl+w两次：分屏切换 分屏的退出:qall //全部退出:wall //保存所有的:wqall //保存并退出所有的 执行shell命令:!{shell命令}e.g.1:!pwd vim配置文件配置文件位置 用户级别：~/.vimrc 系统级别：/etc/vim/vimrc或/etc/vimrc","tags":[{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"},{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"}]},{"title":"linux压缩和解压缩相关技术","date":"2017-10-24T08:33:42.000Z","path":"cjfvw8isg0006u0cnowb03e19.html","text":"linux下常见的压缩格式 .gz –gzip .bz2 -bzip2 常用压缩命令tar打包参数： c：创建压缩文件 x：释放压缩文件 v：打印提示信息 f：指定压缩包名字 z：使用gzip压缩文件 j：使用bzip2的方式压缩文件 压缩 tar 参数 压缩包名字 原材料12tar zcvf aaa.tar.gz ./data //打包并压缩./data下的文件tar zcvf aaa.tar.gz abc def ./data //打包并压缩./data下的文件以及abc、def文件(或目录) 解压缩 tar 参数 压缩包名字 -C 解压目录12tar zxvf aaa.tar.gztar zxvf aaa.tar.gz -C /tmp/aaa rarrar需要安装1sudo apt-get install rar 压缩rar a 压缩包名(不用指定后缀) 压缩内容 解压缩rar x 压缩包名 解压目录 zip/unzip压缩zip 参数 压缩包名 原材料如果有目录，加上参数r 解压缩unzip 压缩包名 -d 解压目录","tags":[{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"},{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"}]},{"title":"linux bash find命令详解","date":"2017-10-24T07:55:00.000Z","path":"cjfvw8isd0005u0cn5vgj2jq6.html","text":"按文件查找find 查找的目录 -name “查找的文件名”e.g.12find . -name \"hachi\"find . -name \"*\" //查找当前目录下的所有文件 按文件类型查找find 查找目录 -type 文件类型 普通文件：f 目录：d 符号链接：l 管道：p 套接字：s 字符设备：c 块设备：be.g. 1find ./ -type d //列出目录 按文件大小查找find 查找的目录 -size [+-]{单位}单位：k：小写M：大写e.g.12find ./ -size +100k //查找当前目录大于100k的文件，包含子目录find ./ -size +100k -size -10M //查找当前目录大于100k，小于10M的文件，包含子目录 按照日期查找 创建日期：-ctime -n/+n (-n：n天以内，+n：n天以外) 修改日期：-mtime 访问时间：-atimee.g. 1find ./ -ctime -1 //查找1天以内创建的文件 按深度查找find 查找的目录 [-maxdepth -mindepth] 搜索深度 maxdepth：n层以内的目录 mindepth：至少n层以上的目录e.g. 1find ./ -maxdepth 3 -name \"hachi\" //查找3层目录以内的hachi文件 结合其他bash命令用法123find ./ -type d -exec ls -l &#123;&#125; \\; //查找当前目录并列出详细信息find ./ -type d -ok ls -l &#123;&#125; \\; //查找当前目录并列出详细信息，每执行一个会询问是否继续find ./ -type d | xargs ls -l //查找当前目录并列出详细信息，这种效率比较高 根据文件内容查找 -grepgrep -r (有子目录) “查找的内容” 搜索的路径e.g.12grep -r \"hachi\" ./ //查找当前目录中带hachi字符串的文件grep -r \"hachi\" ~ -n //查找home目录中带hachi字符串的文件，并显示查出来的字符串在第多少行","tags":[{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"},{"name":"linux","slug":"linux","permalink":"http://limao777.github.io/blog/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://limao777.github.io/blog/tags/shell/"}]},{"title":"java操作文件的几种方法","date":"2017-10-20T01:18:33.000Z","path":"cjfvw8je7001lu0cn2ueg2nzd.html","text":"流式方式写入文件(使用字节)123456789101112131415161718192021/** * 流式方式写入文件(使用字节) * @param path */public static void writeFileUsingByte(String path)&#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(new File(path)); fos.write(\"aaaaa\\r\\nbbb\".getBytes()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 流式方式读取文件(使用字符)123456789101112131415161718192021222324252627/** * 流式方式读取文件(使用字符) * @param path */public static void readFileUsingByte(String path) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream(new File(path)); byte []bytes = new byte[1024]; int n = 0; while((n=fis.read(bytes))!=-1)&#123; String s = new String(bytes,0,n); System.out.println(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 流式方式读取文件(使用字符)123456789101112131415161718192021222324252627/** * 流式方式读取文件(使用字符) * @param path */public static void readFileUsingByte(String path) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream(new File(path)); byte []bytes = new byte[1024]; int n = 0; while((n=fis.read(bytes))!=-1)&#123; String s = new String(bytes,0,n); System.out.println(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 读出文件并写入到另外的文件中（使用字符）123456789101112131415161718192021222324252627282930/** * 读出文件并写入到另外的文件中（使用字符） * @param path */public static void dealFileUsingChar(String readPath, String writePath)&#123; FileReader fr = null; FileWriter wr = null; int n=0; try &#123; fr = new FileReader(readPath); wr = new FileWriter(writePath); char []c=new char[1024]; while((n=fr.read(c))!=-1)&#123; String s = new String(c,0,n); System.out.println(s); wr.write(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; fr.close(); wr.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 读出文件并写入到另外的文件中（使用缓冲）123456789101112131415161718192021222324252627282930/** * 读出文件并写入到另外的文件中（使用缓冲） * @param readPath * @param writePath */public static void dealFileUsingBufferedReader(String readPath, String writePath) &#123; BufferedReader br = null; BufferedWriter wr = null; try &#123; br = new BufferedReader(new FileReader(readPath)); wr = new BufferedWriter(new FileWriter(writePath)); String s=\"\"; while((s=br.readLine())!=null)&#123; System.out.println(s); wr.write(s); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; br.close(); wr.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;","tags":[{"name":"文件","slug":"文件","permalink":"http://limao777.github.io/blog/tags/文件/"}]},{"title":"使用hexo和X-pages搭建个人博客实践","date":"2017-10-13T08:36:55.000Z","path":"cjfvw8je5001ju0cnxp2tykni.html","text":"才将基于github pages的博客系统搭建好，趁热先写写搭建过程中的一些过程，hexo是一个快速、简洁且高效的博客框架，能生成静态页面 前提 安装好nodejs 安装好git nodejs安装进入nodejs官方网站，直接下载安装包安装即可 git安装git也是比较好安装的，git官网下载git软件直接安装好即可，git官网是https://git-scm.com/ 本地化搭建本地化搭建将按照如下方式组织文章 安装hexo 初始化hexo 配置hexo 新增文章 生成静态页面 本地预览 安装hexo1npm install hexo-cli -g 初始化hexo在准备写博客的文件夹处使用命令：12hexo initnpm install 此时将完成了hexo的初始化，如果一切默认配置则可以写文章了，通常我们要简单配置一下hexo 配置hexo通常要配置的选项位于你建立博客根目录的_config.yml文件必要的变更包括# Site、# URL，其他的则可以根据自身需要进行配置其中# Site的配置关于language和timezone比较特殊，都不是随意配置的，须符合一定的language和timezone规则，如language通常配置zh-CN、en等，timezone则配置Asia/Shanghai，这些可以通过搜索引擎搜索Unix的locale语言以及timezone可选的配置如果网站存放在子目录中，例如 http://yoursite.com/blog，则请将 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/最后建立一个about.html文件，通常很多主题模版需要这个文件，hexo中要手动建立一个：1hexo new page 'about' 新增文章使用以下命令创建一篇新文章1hexo new '文章标题' 通过这个命令则在_posts文件夹下面建立了一个文件，该文件使用markdown进行编写，最后生成出来的就是你的博客了 生成静态页面1hexo g 此时public文件夹就是你的博客的静态文件了，可以上传到支持静态文件加载的地方，这样大家就能欣赏你的博客了 本地预览1hexo server 直接使用该命令即可启动本地服务器，照着提示浏览器访问那个端口就即可。如果不嫌麻烦，也可以使用apache、nginx指向public文件夹，效果是一样的 将博客上传到互联网 建立gitpages 代码上传到github 建立gitpages当然，你得有一个github帐号，国内的如码云等git托管网站也有类似的功能在github上建立一个和你名字一模一样的工程，选择该工程的配置，点击pages，点击生成即可，默认的访问方式就是{你的名字}.github.io 代码上传到github1git clone &#123;你的项目&#125; 再复制你的public文件夹到你的git项目中，如果使用了子目录则相应地建立子目录123git add --allgit commit -m 'update blog'git push origin &#123;你的项目&#125; 一些小技巧直接在hexo中使用静态文件在hexo3中，静态文件可通常的markdown格式不一样，可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开打开过后每次新增文章则会相应地在_posts文件夹下建立静态资源目录，将静态资源目录放进去即可，引用方式：12345&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;e.g. &#123;% asset_img example.jpg 这里是alt标签 %&#125; 使用category和tagse.g.123456789---title: testdate: 2017-10-13 13:58:50category: ABCtags:- tag1- tag2- tag3---","tags":[{"name":"git","slug":"git","permalink":"http://limao777.github.io/blog/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://limao777.github.io/blog/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://limao777.github.io/blog/tags/博客/"}]}]